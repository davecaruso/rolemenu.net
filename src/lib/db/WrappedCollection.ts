import type { DataType } from '@davecode/structures';

export type Document<IDType = unknown> = Realm.Services.MongoDB.Document<IDType>;
type Collection<T extends Document> = Realm.Services.MongoDB.MongoDBCollection<T>;
type FindOptions = Realm.Services.MongoDB.FindOptions;
type FindOneOptions = Realm.Services.MongoDB.FindOneOptions;
type FindOneAndModifyOptions = Realm.Services.MongoDB.FindOneAndModifyOptions;
type AggregatePipelineStage = Realm.Services.MongoDB.AggregatePipelineStage;
type CountOptions = Realm.Services.MongoDB.CountOptions;
type InsertOneResult<ID> = Realm.Services.MongoDB.InsertOneResult<ID>;
type InsertManyResult<ID> = Realm.Services.MongoDB.InsertManyResult<ID>;
type DeleteResult = Realm.Services.MongoDB.DeleteResult;
type Filter = Realm.Services.MongoDB.Filter;
type Update = Realm.Services.MongoDB.Update;
type UpdateOptions = Realm.Services.MongoDB.UpdateOptions;
type UpdateResult<ID> = Realm.Services.MongoDB.UpdateResult<ID>;
type ChangeEvent<T> = Realm.Services.MongoDB.ChangeEvent<T & Document>;

export type Migrator<T> = (t: unknown) => T;

export interface WrappedCollectionOptions<T, S> {
	type: DataType<T, S>;
	primaryKey?: string;
	migrator?: Migrator<T>;
}

export class WrappedCollection<T, S> {
	type: DataType<T, S>;
	idField?: any;
	migrator?: Migrator<T>;

	constructor(readonly raw: Collection<Document>, options: WrappedCollectionOptions<T, S>) {
		this.type = options.type;
		this.idField = options.primaryKey;
		this.migrator = options.migrator;
	}

	private fromJSON(data: any) {
		if (this.migrator) {
			return this.migrator(data);
		}
		return this.type.fromJSON(data);
	}

	/**
	 * Finds the documents which match the provided query.
	 *
	 * @param filter An optional filter applied to narrow down the results.
	 * @param options Additional options to apply.
	 * @returns The documents.
	 */
	async find(filter?: Filter, options?: FindOptions): Promise<T[]> {
		const result = await this.raw.find(filter, options);
		return result.map((doc) => this.fromJSON(doc));
	}

	/** Finds the document which has the given id. */
	async findById(id: string): Promise<T | null> {
		const result = await this.raw.findOne({ [this.idField]: id });
		return result ? this.fromJSON(result) : null;
	}

	/**
	 * Finds a document which matches the provided filter.
	 *
	 * @param filter A filter applied to narrow down the result.
	 * @param options Additional options to apply.
	 * @returns The document.
	 */
	async findOne(filter?: Filter, options?: FindOneOptions): Promise<T | null> {
		const result = await this.raw.findOne(filter, options);
		return result ? this.fromJSON(result) : null;
	}

	/**
	 * Finds a document which matches the provided filter and replaces it with a new document.
	 *
	 * @param filter A filter applied to narrow down the result.
	 * @param replacement The new replacing document.
	 * @param options Additional options to apply.
	 * @returns The document found before replacing it.
	 */
	async findOneAndReplace(
		filter: Filter,
		replacement: T,
		options?: FindOneAndModifyOptions
	): Promise<T | null> {
		const result = await this.raw.findOneAndReplace(filter, this.type.toJSON(replacement), options);
		return result ? this.fromJSON(result) : null;
	}

	/**
	 * Finds a document which matches the provided filter and deletes it
	 *
	 * @param filter A filter applied to narrow down the result.
	 * @param options Additional options to apply.
	 * @returns The document found before deleting it.
	 */
	async findOneAndDelete(filter: Filter, options?: FindOneOptions): Promise<T | null> {
		const result = await this.raw.findOneAndDelete(filter, options);
		return result ? this.fromJSON(result) : null;
	}

	/** Counts the number of documents in this collection matching the provided filter. */
	count(filter?: Filter, options?: CountOptions): Promise<number> {
		return this.raw.count(filter, options);
	}

	/**
	 * Inserts a single document into the collection. Note: If the document is missing an _id, one
	 * will be generated for it by the server.
	 *
	 * @param document The document.
	 * @returns The result.
	 */
	async insertOne(document: T): Promise<InsertOneResult<string>> {
		const result = await this.raw.insertOne(this.type.toJSON(document));
		return result as InsertOneResult<string>;
	}

	/**
	 * Inserts an array of documents into the collection. If any values are missing identifiers, they
	 * will be generated by the server.
	 *
	 * @param document The array of documents.
	 * @returns The result.
	 */
	async insertMany(documents: T[]): Promise<InsertManyResult<string>> {
		const json = documents.map((document) => this.type.toJSON(document));
		const result = await this.raw.insertMany(json);
		return result as InsertManyResult<string>;
	}

	/**
	 * Deletes a single matching document from the collection.
	 *
	 * @param filter A filter applied to narrow down the result.
	 * @returns The result.
	 */
	deleteOne(filter: Filter): Promise<DeleteResult> {
		return this.raw.deleteOne(filter);
	}

	/**
	 * Deletes multiple documents.
	 *
	 * @param filter A filter applied to narrow down the result.
	 * @returns The result.
	 */
	deleteMany(filter: Filter): Promise<DeleteResult> {
		return this.raw.deleteMany(filter);
	}

	/**
	 * Replaces a single document in the collection.
	 *
	 * @param item The item to insert
	 */
	async replace(item: T): Promise<void> {
		const json = this.type.toJSON(item);
		await this.raw.findOneAndReplace({ [this.idField]: (json as any)[this.idField] }, json);
	}

	/**
	 * Retrieves the current version of the item.
	 *
	 * @param item The item to retrieve the latest version of.
	 * @returns The latest version of the item.
	 */
	async getLatest(item: T): Promise<T | null> {
		const json = this.type.toJSON(item);
		return this.findById((json as any)[this.idField]);
	}

	/**
	 * Deletes a single matching document from the collection.
	 *
	 * @param item The item to delete
	 * @returns The result.
	 */
	async delete(item: T): Promise<DeleteResult> {
		return this.raw.deleteOne({ [this.idField]: (this.type.toJSON(item) as any)[this.idField] });
	}
}
